import React from 'react';
import './CommonStyles.css';

const JWTExploitWorkflow = () => {
  return (
    <div className="jwt-exploit-workflow">
      <div className="ctf-header">
        <h1>Exploiting JWT Vulnerabilities: A Walkthrough</h1>
        <p>
          This started as a PortSwigger lesson and explores security vulnerabilities in JSON Web Tokens (JWTs) common to API implementations. By analyzing each vulnerability, you’ll see how tools like Hashcat and CyberChef can exploit JWT weaknesses, and how secure development practices can mitigate these risks.
        </p>
      </div>

      <div className="content-section">
        <h3>1. Sensitive Information Disclosure</h3>
        
        <h4>The Risk</h4>
        <p>
          Storing sensitive information in JWTs exposes that data to anyone who gains access to the token. Often, sensitive data like passwords should not be part of the JWT payload.
        </p>

        <h4>Insecure Example</h4>
        <p>
          Below is a JWT payload that improperly includes a user’s password, leading to unnecessary exposure:
        </p>
        <pre><code>{`payload = { "username": "user", "password": "password1", "admin": 0 }`}</code></pre>

        <h4>The Fix</h4>
        <p>
          Only include non-sensitive claims in the JWT, while sensitive data remains server-side and accessible via database queries when needed:
        </p>
        <pre><code>{`payload = { "username": username, "admin": 0 }`}</code></pre>
        <p>Retrieve sensitive data securely with a database query instead:</p>
        <pre><code>{`payload = jwt.decode(token, self.secret, algorithms=["HS256"])\nusername = payload['username']\nflag = self.db_lookup(username, "flag")`}</code></pre>
      </div>

      <div className="content-section">
        <h3>2. Not Verifying the Signature</h3>
        
        <h4>The Risk</h4>
        <p>
          If the signature of a JWT is not verified, attackers can modify claims within the token, such as changing <code>admin</code> status, without detection.
        </p>

        <h4>Insecure Example</h4>
        <p>Example of decoding a JWT without signature verification, leaving the application vulnerable:</p>
        <pre><code>{`payload = jwt.decode(token, options={'verify_signature': False})`}</code></pre>

        <h4>The Fix</h4>
        <p>
          Enforce signature validation with a secret key or public key to verify the JWT’s integrity:
        </p>
        <pre><code>{`payload = jwt.decode(token, self.secret, algorithms=["HS256"])`}</code></pre>
      </div>

      <div className="content-section">
        <h3>3. Downgrading to None Algorithm</h3>
        
        <h4>The Risk</h4>
        <p>
          JWTs allow for the "None" algorithm, which omits the signature. Without enforced algorithm restrictions, an attacker could bypass verification by setting <code>alg</code> to "None".
        </p>

        <h4>Insecure Example</h4>
        <p>
          Setting the <code>alg</code> field to "None" allows a JWT to bypass validation entirely:
        </p>
        <pre><code>{`{ "alg": "None", "typ": "JWT" }`}</code></pre>

        <h4>The Fix</h4>
        <p>
          Restrict signing algorithms to secure options like <code>HS256</code> or <code>RS256</code>, explicitly denying "None":
        </p>
        <pre><code>{`payload = jwt.decode(token, self.secret, algorithms=["HS256"])`}</code></pre>
      </div>

      <div className="content-section">
        <h3>4. Cracking a JWT Using Hashcat</h3>
        
        <h4>The Risk</h4>
        <p>
          If a JWT’s secret key is weak, brute-forcing tools like Hashcat can potentially crack it, allowing attackers to forge valid tokens.
        </p>

        <h4>Cracking Workflow</h4>
        <ol>
          <li><strong>Obtain the JWT:</strong> Save the JWT to a file:</li>
          <pre><code>echo "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZS...F8i5HY" &gt; jwt.txt</code></pre>

          <li><strong>Download a Wordlist of Potential Secrets:</strong> A commonly used list of JWT secrets can be found here:</li>
          <pre><code>wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list</code></pre>

          <li><strong>Use Hashcat to Crack the JWT:</strong> Hashcat’s mode 16500 works for JWT HMAC-SHA256:</li>
          <pre><code>hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list</code></pre>
          <ul>
            <li><code>-m 16500</code>: Specifies JWT HMAC-SHA256 hash type.</li>
            <li><code>-a 0</code>: Attack mode using a wordlist.</li>
          </ul>
        </ol>

        <h4>Cracking Result</h4>
        <pre><code>{`Session..........: hashcat\nStatus...........: Cracked\nHash.Name........: JWT (JSON Web Token)\nHash.Target......: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZS...F8i5HY\nSecret...........: everybody knows it`}</code></pre>
      </div>

      <div className="ctf-summary">
        <h3>Conclusion</h3>
        <p>
          Understanding JWT vulnerabilities helps secure API implementations. By avoiding sensitive claims in payloads, enforcing signature validation, and denying insecure algorithms, developers can prevent many common attacks. Always use the latest libraries and security best practices for JWTs to keep data safe.
        </p>
      </div>
    </div>
  );
};

export default JWTExploitWorkflow;
