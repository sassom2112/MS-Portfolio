import React from 'react';
import './CommonStyles.css';

const JWTExploitWorkflow = () => {
  return (
    <div className="jwt-exploit-workflow">
      <div className="ctf-header">
        <h1>Exploiting JWT Vulnerabilities: A Walkthrough</h1>
        <p>Exploration of common security vulnerabilities in JSON Web Tokens (JWT) in API implementations, using tools like Hashcat and CyberChef to illustrate potential exploitation methods and secure development practices.</p>
      </div>

      <div className="content-section">
        <h3>Sensitive Information Disclosure</h3>
        
        <h4>The Risk</h4>
        <p>JWTs often store sensitive information client-side, creating exposure risks if sensitive data, such as passwords, is placed in the payload. This allows anyone with access to the JWT to easily decode and view its contents.</p>

        <h4>Insecure Example</h4>
        <p>A simple API request where a JWT is returned upon user authentication:</p>
        <p>This returns a JWT containing sensitive user information in the payload:</p>
        <pre><code>{`payload = { "username": "user", "password": "password1", "admin": 0 }`}</code></pre>

        <h4>The Development Mistake</h4>
        <p>In this example, sensitive information (e.g., password) is included in the JWT payload, exposing it to anyone with access to the token.</p>

        <h4>The Fix</h4>
        <p>Store only necessary, non-sensitive claims in the JWT payload. Sensitive data should remain server-side, accessible via database queries:</p>
        <pre><code>{`payload = { "username": username, "admin": 0 }`}</code></pre>
        <p>Retrieve sensitive information with a database lookup:</p>
        <pre><code>{`payload = jwt.decode(token, self.secret, algorithms=["HS256"])
username = payload['username']
flag = self.db_lookup(username, "flag")`}</code></pre>
      </div>

      <div className="content-section">
        <h3>Not Verifying the Signature</h3>
        
        <h4>The Risk</h4>
        <p>Failing to verify the JWT signature allows attackers to modify tokens and potentially gain unauthorized access by altering claims such as <code>admin</code> status.</p>

        <h4>Insecure Example</h4>
        <p>If an API does not verify the JWT signature, attackers could modify the token to gain privileges:</p>
        <pre><code>{`payload = jwt.decode(token, options={'verify_signature': False})`}</code></pre>

        <h4>The Development Mistake</h4>
        <p>By not validating the signature, attackers can manipulate the JWT without detection, posing a severe security risk.</p>

        <h4>The Fix</h4>
        <p>Enforce signature validation with a predefined secret or public key to ensure token integrity:</p>
        <pre><code>{`payload = jwt.decode(token, self.secret, algorithms=["HS256"])`}</code></pre>
      </div>

      <div className="content-section">
        <h3>Downgrading to None Algorithm</h3>
        
        <h4>The Risk</h4>
        <p>The "None" algorithm in JWT allows for tokens without a signature. If developers do not enforce a specific signing algorithm, attackers could modify tokens to bypass signature checks.</p>

        <h4>Insecure Example</h4>
        <p>By setting the <code>alg</code> claim to "None" and removing the signature, the token can bypass validation:</p>
        <pre><code>{`{ "alg": "None", "typ": "JWT" }`}</code></pre>

        <h4>The Development Mistake</h4>
        <p>Allowing the "None" algorithm in the JWT header without explicitly enforcing a secure algorithm can lead to unauthorized access.</p>

        <h4>The Fix</h4>
        <p>Restrict the signing algorithm to secure options like <code>HS256</code> or <code>RS256</code> and deny "None":</p>
        <pre><code>{`payload = jwt.decode(token, self.secret, algorithms=["HS256"])`}</code></pre>
      </div>

      <div className="content-section">
        <h3>Cracking a JWT Using Hashcat</h3>
        
        <h4>The Risk</h4>
        <p>If the JWT secret key is weak, attackers can use brute-force techniques to crack it and generate valid tokens. Hashcat is a powerful tool often used for this purpose.</p>

        <h4>Workflow to Crack JWT</h4>
        <ol>
          <li><strong>Obtain the JWT:</strong> Save the JWT to a file:</li>
          <pre><code>echo "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZS...F8i5HY" `&gt;` jwt.txt</code></pre>

          <li><strong>Get a List of Common JWT Secrets:</strong> Download a list of potential secrets:</li>
          <pre><code>wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list</code></pre>

          <li><strong>Crack the JWT with Hashcat:</strong> Use the hash mode for JWT (16500):</li>
          <pre><code>hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list</code></pre>
          <ul>
            <li><code>-m 16500</code>: Specifies JWT HMAC-SHA256 hash type.</li>
            <li><code>-a 0</code>: Attack mode using a wordlist.</li>
            <li><code>jwt.txt</code>: The file containing the JWT to crack.</li>
            <li><code>jwt.secrets.list</code>: Wordlist of potential secrets.</li>
          </ul>
        </ol>

        <h4>Cracking Result</h4>
        <pre><code>{`Session..........: hashcat
Status...........: Cracked
Hash.Name........: JWT (JSON Web Token)
Hash.Target......: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZS...F8i5HY
Secret...........: everybody knows it`}</code></pre>
      </div>

      <div className="ctf-summary">
        <h3>Conclusion</h3>
        <p>APIs are vulnerable when JWTs are improperly implemented. By avoiding sensitive information in JWT claims, enforcing signature validation, and denying insecure algorithms, developers can enhance security. Using the latest libraries and security standards helps safeguard data from common JWT vulnerabilities.</p>
      </div>
    </div>
  );
};

export default JWTExploitWorkflow;
